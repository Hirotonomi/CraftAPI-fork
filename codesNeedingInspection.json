[
    {
        "localization": "/app/projects/CraftAPI-fork_Hirotonomi/src/test/java/com/github/games647/craftapi/resolver/http/RotatingSourceFactoryTest.java",
        "code": "package com.github.games647.craftapi.resolver.http;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass RotatingSourceFactoryTest {\n\n    private SSLSocketFactory mockOldFactory;\n    private RotatingSourceFactory rotatingSourceFactory;\n\n    @BeforeEach\n    void setUp() {\n        mockOldFactory = Mockito.mock(SSLSocketFactory.class);\n        rotatingSourceFactory = new RotatingSourceFactory(mockOldFactory);\n    }\n\n    @Test\n    void testCreateSocket_noOutgoingAddress_socketCreatedWithoutBinding() throws IOException {\n        Socket mockSocket = Mockito.mock(Socket.class);\n        Mockito.when(mockOldFactory.createSocket()).thenReturn(mockSocket);\n\n        Socket result = rotatingSourceFactory.createSocket();\n\n        assertNotNull(result);\n        Mockito.verify(mockSocket, Mockito.never()).bind(Mockito.any());\n    }\n\n    @Test\n    void testCreateSocket_withOutgoingAddress_socketCreatedWithBinding() throws IOException {\n        InetAddress mockAddress = Mockito.mock(InetAddress.class);\n        rotatingSourceFactory.setOutgoingAddresses(Collections.singletonList(mockAddress));\n\n        Socket mockSocket = Mockito.mock(Socket.class);\n        Mockito.when(mockOldFactory.createSocket()).thenReturn(mockSocket);\n\n        Socket result = rotatingSourceFactory.createSocket();\n\n        assertNotNull(result);\n        Mockito.verify(mockSocket).bind(Mockito.any());\n    }\n\n    @Test\n    void testGetNextLocalAddress_noAddressesSet_emptyOptional() {\n        Optional<InetAddress> result = rotatingSourceFactory.getNextLocalAddress();\n\n        assertFalse(result.isPresent(), \"Expected empty Optional when no addresses are set\");\n    }\n\n    @Test\n    void testGetNextLocalAddress_addressesSet_returnsCycle() {\n        InetAddress address1 = Mockito.mock(InetAddress.class);\n        InetAddress address2 = Mockito.mock(InetAddress.class);\n        rotatingSourceFactory.setOutgoingAddresses(Arrays.asList(address1, address2));\n\n        Optional<InetAddress> first = rotatingSourceFactory.getNextLocalAddress();\n        Optional<InetAddress> second = rotatingSourceFactory.getNextLocalAddress();\n        Optional<InetAddress> third = rotatingSourceFactory.getNextLocalAddress();\n\n        assertTrue(first.isPresent());\n        assertTrue(second.isPresent());\n        assertTrue(third.isPresent());\n        assertEquals(first.get(), third.get(), \"Expected the cycle to repeat\");\n    }\n}"
    },
    {
        "localization": "/app/projects/CraftAPI-fork_Hirotonomi/src/test/java/com/github/games647/craftapi/resolver/http/RotatingSourceFactoryTest.java",
        "code": "package com.github.games647.craftapi.resolver.http;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class RotatingSourceFactoryTest {\n\n    private SSLSocketFactory mockOldFactory;\n    private RotatingSourceFactory rotatingSourceFactory;\n\n    @BeforeEach\n    public void setUp() {\n        mockOldFactory = Mockito.mock(SSLSocketFactory.class);\n        rotatingSourceFactory = new RotatingSourceFactory(mockOldFactory);\n    }\n\n    @Test\n    public void testCreateSocket_bindsToNextLocalAddress() throws IOException {\n        Socket mockSocket = Mockito.mock(Socket.class);\n        when(mockOldFactory.createSocket()).thenReturn(mockSocket);\n\n        InetAddress address1 = InetAddress.getByName(\"192.168.1.1\");\n        InetAddress address2 = InetAddress.getByName(\"192.168.1.2\");\n        rotatingSourceFactory.setOutgoingAddresses(Arrays.asList(address1, address2));\n\n        Socket createdSocket = rotatingSourceFactory.createSocket();\n\n        verify(mockSocket).bind(any());\n        assertNotNull(createdSocket);\n    }\n\n    @Test\n    public void testCreateSocket_noLocalAddressAvailable() throws IOException {\n        Socket mockSocket = Mockito.mock(Socket.class);\n        when(mockOldFactory.createSocket()).thenReturn(mockSocket);\n\n        rotatingSourceFactory.setOutgoingAddresses(Collections.emptyList());\n\n        Socket createdSocket = rotatingSourceFactory.createSocket();\n\n        verify(mockSocket, never()).bind(any());\n        assertNotNull(createdSocket);\n    }\n\n    @Test\n    public void testGetDefaultCipherSuites_delegation() {\n        String[] suites = {\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"};\n        when(mockOldFactory.getDefaultCipherSuites()).thenReturn(suites);\n\n        assertArrayEquals(suites, rotatingSourceFactory.getDefaultCipherSuites());\n    }\n\n    @Test\n    public void testGetSupportedCipherSuites_delegation() {\n        String[] suites = {\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"};\n        when(mockOldFactory.getSupportedCipherSuites()).thenReturn(suites);\n\n        assertArrayEquals(suites, rotatingSourceFactory.getSupportedCipherSuites());\n    }\n\n    @Test\n    public void testGetNextLocalAddress_emptyIterator() {\n        Optional<InetAddress> nextAddress = rotatingSourceFactory.getNextLocalAddress();\n        assertFalse(nextAddress.isPresent());\n    }\n}"
    },
    {
        "localization": "/app/projects/CraftAPI-fork_Hirotonomi/src/test/java/com/github/games647/craftapi/resolver/http/RotatingSourceFactoryTest.java",
        "code": "package com.github.games647.craftapi.resolver.http;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.Collections;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass RotatingSourceFactoryTest {\n\n    @Mock\n    private SSLSocketFactory oldFactory;\n\n    @InjectMocks\n    private RotatingSourceFactory rotatingSourceFactory;\n\n    private InetAddress address1;\n    private InetAddress address2;\n\n    @BeforeEach\n    void setUp() throws Exception {\n        address1 = InetAddress.getByName(\"192.168.1.1\");\n        address2 = InetAddress.getByName(\"192.168.1.2\");\n    }\n\n    @Test\n    void testCreateSocket_noAddresses_defaultBehavior() throws IOException {\n        Socket socket = mock(Socket.class);\n        when(oldFactory.createSocket()).thenReturn(socket);\n\n        Socket createdSocket = rotatingSourceFactory.createSocket();\n\n        assertEquals(socket, createdSocket);\n        verify(oldFactory).createSocket();\n    }\n\n    @Test\n    void testSetOutgoingAddresses_rotatesCorrectly() {\n        rotatingSourceFactory.setOutgoingAddresses(Collections.singleton(address1));\n\n        Optional<InetAddress> firstAddress = rotatingSourceFactory.getNextLocalAddress();\n        assertTrue(firstAddress.isPresent());\n        assertEquals(address1, firstAddress.get());\n\n        Optional<InetAddress> secondAddress = rotatingSourceFactory.getNextLocalAddress();\n        assertTrue(secondAddress.isPresent());\n        assertEquals(address1, secondAddress.get());\n    }\n\n    @Test\n    void testSetOutgoingAddresses_emptyCollection() {\n        rotatingSourceFactory.setOutgoingAddresses(Collections.emptySet());\n\n        Optional<InetAddress> address = rotatingSourceFactory.getNextLocalAddress();\n        assertFalse(address.isPresent());\n    }\n\n    @Test\n    void testCreateSocket_bindToNextAddress() throws IOException {\n        Socket socket = mock(Socket.class);\n        when(oldFactory.createSocket()).thenReturn(socket);\n        rotatingSourceFactory.setOutgoingAddresses(Collections.singletonList(address1));\n\n        Socket createdSocket = rotatingSourceFactory.createSocket();\n\n        verify(socket).bind(any());\n        assertEquals(socket, createdSocket);\n    }\n\n    @Test\n    void testGetDefaultCipherSuites_delegates() {\n        String[] cipherSuites = new String[]{\"TLS_RSA_WITH_AES_128_CBC_SHA\"};\n        when(oldFactory.getDefaultCipherSuites()).thenReturn(cipherSuites);\n\n        assertArrayEquals(cipherSuites, rotatingSourceFactory.getDefaultCipherSuites());\n    }\n\n    @Test\n    void testGetSupportedCipherSuites_delegates() {\n        String[] cipherSuites = new String[]{\"TLS_RSA_WITH_AES_128_CBC_SHA\"};\n        when(oldFactory.getSupportedCipherSuites()).thenReturn(cipherSuites);\n\n        assertArrayEquals(cipherSuites, rotatingSourceFactory.getSupportedCipherSuites());\n    }\n}"
    }
]